use crate::ast::*;
use crate::lexer::Token;

pub struct Parser {
  tokens: Vec<(usize, Token, usize)>,
  current: usize,
}

impl Parser {
  /// Creates a new `Parser` instance.
  ///
  /// # Arguments
  ///
  /// * `tokens` - A vector of tokens generated by the lexer, each with its position.
  pub fn new(tokens: Vec<(usize, Token, usize)>) -> Self {
    Self {
      tokens,
      current: 0,
    }
  }

  /// Parses the stream of tokens and constructs an Abstract Syntax Tree (AST).
  ///
  /// This is the main entry point for the parsing process.
  ///
  /// # Returns
  ///
  /// A vector of `Stmt` (statements) representing the parsed program.
  pub fn parse(&mut self) -> Vec<Stmt> {
    let mut statements = Vec::new();
    while !self.is_at_end() {
      statements.push(self.declaration());
    }
    statements
  }

  // Parses a declaration, which can be a variable declaration, function declaration, or a statement.
  fn declaration(&mut self) -> Stmt {
    match self.peek() {
      Token::Var => self.var_decl(),
      Token::Function => self.function(),
      _ => self.statement(),
    }
  }

  // Parses a variable declaration statement.
  fn var_decl(&mut self) -> Stmt {
    self.advance(); // Consume 'Var'
    let name = if let Token::Identifier(name) = self.advance() {
      name.clone()
    } else {
      panic!("Expected variable name");
    };

    let type_annotation = if self.match_token(&[Token::Colon]) {
      Some(self.parse_type())
    } else {
      None
    };

    let initializer = if self.match_token(&[Token::Eq]) {
      Some(self.expression())
    } else {
      None
    };

    self.consume(Token::Semicolon, "Expected ';' after variable declaration");

    Stmt::VarDecl {
      name,
      type_annotation,
      initializer,
    }
  }

  // Parses a statement, which can be an if statement, return statement, panic statement, or an expression statement.
  fn statement(&mut self) -> Stmt {
    match self.peek() {
      Token::If => self.if_statement(),
      Token::Return => {
        self.advance();
        let expr = if self.check(&Token::Semicolon) {
          None
        } else {
          Some(self.expression())
        };
        self.consume(Token::Semicolon, "Expected ';' after");
        Stmt::Return(expr)
      }
      Token::Panic => {
        self.advance();
        let expr = self.expression();
        self.consume(Token::Semicolon, "Expected ';' after panic");
        Stmt::Panic(expr)
      }
      _ => {
        let expr = self.expression();
        self.consume(Token::Semicolon, "Expected ';'");
        Stmt::Expression(expr)
      }
    }
  }

  // Parses an if-else statement.
  fn if_statement(&mut self) -> Stmt {
    self.advance(); // consume 'if'
    self.consume(Token::LParen, "Expected '(' after if");
    let condition = self.expression();
    self.consume(Token::RParen, "Expected ')' after condition");

    self.consume(Token::LBrace, "Expected '{' before then block");
    let then_block = self.block();
    let else_block = if self.match_token(&[Token::Else]) {
      self.consume(Token::LBrace, "Expected '{' before else block");
      Some(self.block())
    } else {
      None
    };

    Stmt::If {
      condition,
      then_branch: then_block,
      else_branch: else_block,
    }
  }

  // Parses a block of statements enclosed in curly braces.
  fn block(&mut self) -> Vec<Stmt> {
    let mut stmts = Vec::new();
    while !self.check(&Token::RBrace) && !self.is_at_end() {
      stmts.push(self.declaration());
    }
    self.consume(Token::RBrace, "Expected '}'");
    stmts
  }

  // Parses a function declaration.
  fn function(&mut self) -> Stmt {
    self.advance(); // consume 'function'
    let name = if let Token::Identifier(n) = self.advance() {
      n.clone()
    } else {
      panic!("Expected function name");
    };

    self.consume(Token::LParen, "Expected '(' after function name");
    let mut params = Vec::new();
    while !self.check(&Token::RParen) {
      let param_name = if let Token::Identifier(name) = self.advance() {
        name.clone()
      } else {
        panic!("Expected parameter name");
      };
      self.consume(Token::Colon, "Expected ':' in parameter");
      let param_type = self.parse_type();
      params.push((param_name, param_type));
      if !self.check(&Token::RParen) {
        self.consume(Token::Comma, "Expected ',' between parameters");
      }
    }
    self.consume(Token::RParen, "Expected ')' after parameters");

    let return_type = if self.match_token(&[Token::Returns]) {
      Some(self.parse_type())
    } else {
      None
    };

    self.consume(Token::LBrace, "Expected '{' before function body");
    let body = self.block();

    Stmt::Function {
      name,
      params,
      return_type,
      body: body,
    }
  }

  // Parses an expression.
  fn expression(&mut self) -> Expr {
    self.assignment()
  }

  // Parses an assignment expression.
  fn assignment(&mut self) -> Expr {
    let expr = self.logic_or();

    if self.match_token(&[Token::Eq]) {
      let value = self.assignment();

      if let Expr::Variable(name) = expr {
        return Expr::Assign { name, value: Box::new(value) };
      }

      panic!("Invalid assignment target");
    }

    expr
  }

  // Parses a logical OR expression.
  fn logic_or(&mut self) -> Expr {
    let mut expr = self.logic_and();

    while self.match_token(&[Token::PipePipe]) {
      let op = BinaryOp::Or;
      let right = self.logic_and();
      expr = Expr::Binary(Box::new(expr), op, Box::new(right));
    }

    expr
  }

  // Parses a logical AND expression.
  fn logic_and(&mut self) -> Expr {
    let mut expr = self.equality();

    while self.match_token(&[Token::AmpAmp]) {
      let op = BinaryOp::And;
      let right = self.equality();
      expr = Expr::Binary(Box::new(expr), op, Box::new(right));
    }

    expr
  }

  // Parses an equality or inequality expression.
  fn equality(&mut self) -> Expr {
    let mut expr = self.comparison();

    while self.match_token(&[Token::EqEq, Token::BangEq]) {
      let op = match self.previous() {
        Token::EqEq => BinaryOp::EqualEqual,
        Token::BangEq => BinaryOp::NotEqual,
        _ => unreachable!(),
      };
      let right = self.comparison();
      expr = Expr::Binary(Box::new(expr), op, Box::new(right));
    }

    expr
  }

  // Parses a comparison expression (>, >=, <, <=).
  fn comparison(&mut self) -> Expr {
    let mut expr = self.term();

    while self.match_token(&[
      Token::Gt,
      Token::Ge,
      Token::Lt,
      Token::Le,
    ]) {
      let op = match self.previous() {
        Token::Gt => BinaryOp::Greater,
        Token::Ge => BinaryOp::GreaterEqual,
        Token::Lt => BinaryOp::Less,
        Token::Le => BinaryOp::LessEqual,
        _ => unreachable!(),
      };
      let right = self.term();
      expr = Expr::Binary(Box::new(expr), op, Box::new(right));
    }

    expr
  }

  // Parses a term expression (+, -).
  fn term(&mut self) -> Expr {
    let mut expr = self.factor();

    while self.match_token(&[Token::Plus, Token::Minus]) {
      let op = match self.previous() {
        Token::Plus => BinaryOp::Plus,
        Token::Minus => BinaryOp::Minus,
        _ => unreachable!(),
      };
      let right = self.factor();
      expr = Expr::Binary(Box::new(expr), op, Box::new(right));
    }

    expr
  }

  // Parses a factor expression (*, /).
  fn factor(&mut self) -> Expr {
    let mut expr = self.unary();

    while self.match_token(&[Token::Star, Token::Slash]) {
      let op = match self.previous() {
        Token::Star => BinaryOp::Star,
        Token::Slash => BinaryOp::Slash,
        _ => unreachable!(),
      };
      let right = self.unary();
      expr = Expr::Binary(Box::new(expr), op, Box::new(right));
    }

    expr
  }

  // Parses a unary expression (!, -).
  fn unary(&mut self) -> Expr {
    if self.match_token(&[Token::Bang, Token::Minus]) {
      let op = match self.previous() {
        Token::Bang => UnaryOp::Bang,
        Token::Minus => UnaryOp::Minus,
        _ => unreachable!(),
      };
      let right = self.unary();
      return Expr::Unary(op, Box::new(right));
    }

    self.primary()
  }

  // Parses a primary expression (literals, identifiers, grouped expressions).
  fn primary(&mut self) -> Expr {
    match self.advance() {
      Token::True => Expr::Literal(Literal::Boolean(true)),
      Token::False => Expr::Literal(Literal::Boolean(false)),
      Token::Number(n) => Expr::Literal(Literal::Number(*n)),
      Token::StringLiteral(s) => Expr::Literal(Literal::String(s.clone())),
      Token::Identifier(name) => Expr::Variable(name.clone()),
      Token::LParen => {
        let expr = self.expression();
        self.consume(Token::RParen, "Expected ')' after expression");
        Expr::Grouping(Box::new(expr))
      }
      t => panic!("Unexpected token in expression: {:?}", t),
    }
  }

  // Parses a type annotation.
  fn parse_type(&mut self) -> String {
    match self.advance() {
      Token::Identifier(s) => s.clone(),
      Token::Int => "int".to_string(),
      Token::String => "string".to_string(),
      Token::Boolean => "boolean".to_string(),
      Token::Float => "float".to_string(),
      t => panic!("Expected type, found {:?}", t),
    }
  }

  //-------------- Helpers ---------------------------

  // Checks if the parser has reached the end of the token stream.
  fn is_at_end(&self) -> bool {
    self.current >= self.tokens.len()
  }

  // Peeks at the current token without consuming it.
  fn peek(&self) -> &Token {
    &self.tokens[self.current].1
  }

  // Returns the previously consumed token.
  fn previous(&self) -> &Token {
    &self.tokens[self.current - 1].1
  }

  // Consumes the current token and advances the parser.
  fn advance(&mut self) -> &Token {
    if !self.is_at_end() {
      self.current += 1;
    }
    self.previous()
  }

  // Checks if the current token matches the expected token.
  fn check(&self, expected: &Token) -> bool {
    !self.is_at_end() && self.peek() == expected
  }

  // Consumes the current token if it matches any of the given types.
  fn match_token(&mut self, types: &[Token]) -> bool {
    for t in types {
      if self.peek() == t {
        self.advance();
        return true;
      }
    }
    false
  }

  // Consumes the current token if it matches the expected token, otherwise panics.
  fn consume(&mut self, expected: Token, msg: &str) {
    if self.peek() == &expected {
      self.advance();
    } else {
      panic!("{}", msg);
    }
  }
}